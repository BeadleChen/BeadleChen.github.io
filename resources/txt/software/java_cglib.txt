<h3>一、 CGLIB介绍</h3>

<p>
　　代理为控制要访问的目标对象提供了一种途径。当访问对象时，它引入了一个间接的层。
JDK自从1.3版本开始，就引入了动态代理，并且经常被用来动态地创建代理。JDK的动态代理
用起来非常简单，但它有一个限制，就是使用动态代理的对象必须实现一个或多个接口。
如果想代理没有实现接口的继承的类，该怎么办？现在我们可以使用CGLIB包.</br>

　　CGLIB是一个强大的高性能的代码生成包。它广泛的被许多AOP的框架使用，
例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。最流行的
OR Mapping工具hibernate也使用CGLIB来代理单端single-ended(多对一和一对一)
关联（对集合的延迟抓取，是采用其他机制实 现的）。EasyMock和jMock是通过使用模仿（moke）
对象来测试java代码的包。它们都通过使用CGLIB来为那些没有接口的类创建模仿（moke）对象。
CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。
除了CGLIB包，脚本语言例如 Groovy和BeanShell，也是使用ASM来生成java的字节码。
但不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</br>

　　需要注意的是一些框架例如Spring AOP和Hibernate，它们为了满足需要经常同时
使用JDK的动态代理和CGLIB包。Hiberater使用JDK的动态代理实现一个专门为
WebShere应用服务器的事务管理适配器；Spring AOP，如果不强制使用CGLIB包，
默认情况是使用JDK的动态代理来代理接口。
</p>

<h3>二、 CGLIB 代理的APIS</h3>

<p>
•net.sf.cglib.core</br>
底层字节码处理类，他们大部分与ASM有关系。</br>
• net.sf.cglib.transform</br>
编译期或运行期类和类文件的转换</br>
• net.sf.cglib.proxy</br>
实现创建代理和方法拦截器的类</br>
• net.sf.cglib.reflect</br>
实现快速反射和C#风格代理的类</br>
• net.sf.cglib.util</br>
集合排序工具类</br>
• net.sf.cglib.beans</br>
JavaBean相关的工具类</br>

</p>

<p>
本质上，它是通过动态的生成一个子类去覆盖所要代理类的不是final的方法，</br>
并设置好callback，则原有类的每个方法调用就会转变成调用用户定义的拦截</br>
方法（interceptors），这比 JDK动态代理方法快多了。
</p>

<p>
Callback类型</br>
• net.sf.cglib.proxy.FixedValue </br>
为提高性能，FixedValue回调对强制某一特别方法返回固定值是有用的。</br>
• net.sf.cglib.proxy.NoOp </br>
NoOp回调把对方法调用直接委派到这个方法在父类中的实现。</br>
• net.sf.cglib.proxy.LazyLoader </br>
当实际的对象需要延迟装载时，可以使用LazyLoader回调。</br>
一旦实际对象被装载，它将被每一个调用代理对象的方法使用。</br>
• net.sf.cglib.proxy.Dispatcher </br>
Dispathcer回调和LazyLoader回调有相同的特点，</br>
不同的是，当代理方法被调用时，装载对象的方法也总要被调用。</br>
• net.sf.cglib.proxy.ProxyRefDispatcher </br>
ProxyRefDispatcher回调和Dispatcher一样，</br>
不同的是，它可以把代理对象作为装载对象方法的一个参数传递。</br>
</p>

<h3>二、 简单模拟Proxy.newProxyInstance()生成代理对象</h3>

<p>
原理:通过传递过来的Interface的Class对象，模拟生成代理对象的java文件字符串，</br>
通过在本地生成文件，并使用Java自带Compiler进行编译，用类加载器进行加载并实例化代理对象。</br>
</p>
<p>
<div class="border_area">
public class Proxy {</br>
　　　　public static Object newProxyInstance(Class interfaceClass,InvocationHandler handler){</br>
　　　　　　　　Method[] methods = interfaceClass.getMethods();</br>
　　　　　　　　String packageName = Proxy.class.getPackage().getName();</br>
　　　　　　　　String className = "$Proxy0";</br>
　　　　　　　　String r = "\r";</br>
　　　　　　　　String fileContent = "package "+packageName+";"+r+</br>
　　　　　　　　　　　　　　　　"import java.lang.reflect.Method;"+r+r+</br>
　　　　　　　　　　　　　　　　"public class "+className+" implements "+</br>
　　　　　　　　　　　　　　　　　　　　interfaceClass.getCanonicalName() + "{"+r+</br>
　　　　　　　　　　　　　　　　"    private InvocationHandler handler;"+r+</br>
　　　　　　　　　　　　　　　　"    public "+className+"(InvocationHandler handler){"+r+</br>
　　　　　　　　　　　　　　　　"        this.handler = handler;"+r+</br>
　　　　　　　　　　　　　　　　"    }"+r;</br>
　　　　　　　　for(Method method : methods){</br>
　　　　　　　　　　　　fileContent += </br>
　　　　　　　　　　　　　　　　"    public "+method.getReturnType().getName()+" "+</br>
　　　　　　　　　　　　　　　　　　　　method.getName()+"(";</br>
　　　　　　　　　　　　Parameter[] parameters = method.getParameters();</br>
　　　　　　　　　　　　String args = "";</br>
　　　　　　　　　　　　String argClasses = "";</br>
　　　　　　　　　　　　for(int i=0; i&lt;parameters.length ;i++){</br>
　　　　　　　　　　　　　　　　Class paramType = parameters[i].getType();</br>
　　　　　　　　　　　　　　　　String paramName = parameters[i].getName();</br>
　　　　　　　　　　　　　　　　argClasses += paramType+".class";</br>
　　　　　　　　　　　　　　　　args += paramName;</br>
　　　　　　　　　　　　　　　　fileContent += paramType + " "+ paramName;</br>
　　　　　　　　　　　　　　　　if(i != (parameters.length-1)){</br>
　　　　　　　　　　　　　　　　　　　　argClasses += ",";</br>
　　　　　　　　　　　　　　　　　　　　args += ",";</br>
　　　　　　　　　　　　　　　　　　　　fileContent += ",";</br>
　　　　　　　　　　　　　　　　}</br>
　　　　　　　　　　　　}</br>
　　　　　　　　　　　　fileContent += "){"+r;</br>
　　　　　　　　　　　　String param2 = null;</br>
　　　　　　　　　　　　String param3 = null;</br>
　　　　　　　　　　　　if(args.equals("")){</br>
　　　　　　　　　　　　　　　　param2 = interfaceClass.getCanonicalName()+</br>
　　　　　　　　　　　　　　　　　　　　　　　　".class.getMethod(\""+method.getName()+"\")";</br>
　　　　　　　　　　　　　　　　param3 = "null";</br>
　　　　　　　　　　　　}else{</br>
　　　　　　　　　　　　　　　　param2 = interfaceClass.getCanonicalName()+</br>
　　　　　　　　　　　　　　　　　　　　　　　　".class.getMethod(\""+method.getName()+</br>
　　　　　　　　　　　　　　　　　　　　　　　　"\","+argClasses+")";</br>
　　　　　　　　　　　　　　　　fileContent += </br>
　　　　　　　　　　　　　　　　"        Object[] objs={"+args+"};"+r;</br>
　　　　　　　　　　　　　　　　param3 = "objs";</br>
　　　　　　　　　　　　}</br>
　　　　　　　　　　　　fileContent +=</br>
　　　　　　　　　　　　　　　　"        Method method = null;"+r+</br>
　　　　　　　　　　　　　　　　"        try{"+r+</br>
　　　　　　　　　　　　　　　　"            method = "+param2+";"+r+</br>
　　　　　　　　　　　　　　　　"        }catch(Exception e){e.printStackTrace();}"+r;</br>
　　　　　　　　　　　　String returnStr = "";</br>
　　　　　　　　　　　　if(method.getReturnType()==void.class){	</br>
　　　　　　　　　　　　}else if(method.getReturnType()==int.class){</br>
　　　　　　　　　　　　　　　　returnStr = "return (Integer)";</br>
　　　　　　　　　　　　}</br>
　　　　　　　　　　　　fileContent += </br>
　　　　　　　　　　　　　　　　"        "+returnStr+" this.handler.invoke(this,method,"+param3+");"+r+</br>
　　　　　　　　　　　　　　　　"    }"+r;</br>
　　　　　　　　}</br>
　　　　　　　　fileContent += "}";</br>
　　　　　　　　File file = new File("F:/compiler/src/"+packageName.replace(".", "/")</br>
　　　　　　　　　　　　　　　　　　　　　　　　+"/"+className+".java");</br>
　　　　　　　　try{</br>
　　　　　　　　　　　　file.getParentFile().mkdirs();</br>
　　　　　　　　　　　　FileOutputStream fos = new FileOutputStream(file);</br>
　　　　　　　　　　　　fos.write(fileContent.getBytes());</br>
　　　　　　　　　　　　fos.close();</br>
　　　　　　　　}catch(Exception e){</br>
　　　　　　　　　　　　e.printStackTrace();</br>
　　　　　　　　}</br>
　　　　　　　　JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</br>
　　　　　　　　StandardJavaFileManager fileMgr = </br>
　　　　　　　　　　　　　　　　compiler.getStandardFileManager(null, null, null);</br>
　　　　　　　　Iterable units = fileMgr.getJavaFileObjects(file);</br>
　　　　　　　　CompilationTask ct = compiler.getTask(null, fileMgr, null, null, null, units);</br>
　　　　　　　　ct.call();</br>
　　　　　　　　try {</br>
　　　　　　　　　　　　fileMgr.close();</br>
　　　　　　　　　　　　URL[] urls = new URL[] {new URL("file:/F:/compiler/src/")};</br>
　　　　　　　　　　　　ClassLoader ul = new URLClassLoader(urls);</br>
　　　　　　　　　　　　Class clazz = ul.loadClass(packageName+"."+className);</br>
　　　　　　　　　　　　Constructor con = clazz.getConstructor(InvocationHandler.class);</br>
　　　　　　　　　　　　return con.newInstance(handler);</br>
　　　　　　　　} catch (Exception e) {</br>
　　　　　　　　　　　　e.printStackTrace();</br>
　　　　　　　　}</br>
　　　　　　　　return null;</br>
　　　　}	</br>
　　　　public static void main(String[] args){</br>
　　　　　　　　final Caculatable c = new Caculatable() {</br>
　　　　　　　　　　　　@Override</br>
　　　　　　　　　　　　public void multiply() {</br>
　　　　　　　　　　　　　　　　System.out.println("multiply");</br>
　　　　　　　　　　　　}</br>
　　　　　　　　　　　　@Override</br>
　　　　　　　　　　　　public int add(int x, int y) {</br>
　　　　　　　　　　　　　　　　return x+y;</br>
　　　　　　　　　　　　}</br>
　　　　　　　　};</br>
　　　　　　　　Caculatable proxy=(Caculatable)Proxy.newProxyInstance(</br>
　　　　　　　　　　　　Caculatable.class, </br>
　　　　　　　　　　　　new InvocationHandler() {</br>
　　　　　　　　　　　　　　　　@Override</br>
　　　　　　　　　　　　　　　　public Object invoke(Object proxy, Method method, Object[] args) {</br>
　　　　　　　　　　　　　　　　　　　　try {</br>
　　　　　　　　　　　　　　　　　　　　　　　　System.out.println("before proxy");</br>
　　　　　　　　　　　　　　　　　　　　　　　　Object obj = method.invoke(c, args);</br>
　　　　　　　　　　　　　　　　　　　　　　　　System.out.println("after proxy");</br>
　　　　　　　　　　　　　　　　　　　　　　　　return obj;</br>
　　　　　　　　　　　　　　　　　　　　} catch (Exception e) {</br>
　　　　　　　　　　　　　　　　　　　　　　　　e.printStackTrace();</br>
　　　　　　　　　　　　　　　　　　　　}</br>
　　　　　　　　　　　　　　　　return null;</br>
　　　　　　　　　　　　　　　　}</br>
　　　　　　　　　　　　}</br>
　　　　　　　　);</br>
　　　　　　　　System.out.println(proxy.add(1, 2));</br>
　　　　　　　　proxy.multiply();</br>
　　　　}</br>
}</br>
</div>
</p>